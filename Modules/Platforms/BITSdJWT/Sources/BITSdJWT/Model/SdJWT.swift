import BITCore
import BITCrypto
import BITJWT
import Foundation

// MARK: - SdJWTError

enum SdJWTError: Error {
  case invalidJWTPayload
  case encodingDisclosureError
  case invalidClaimKey
}

// MARK: - SdJWT

/// https://www.ietf.org/archive/id/draft-ietf-oauth-selective-disclosure-jwt-12.html

open class SdJWT: JWT {

  // MARK: Lifecycle

  public init(from rawSdJWT: String, sdJWTDecoder: SdJWTDecoder = SdJWTDecoder()) throws {
    digests = try sdJWTDecoder.decodeDigests(from: rawSdJWT)
    disclosableClaims = try sdJWTDecoder.decodeClaims(from: rawSdJWT, digests: digests)

    try super.init(from: rawSdJWT)
  }

  // MARK: Public

  public static let disclosuresSeparator = "~"

  /// The list of digests contained in the VC generated by the issuer for each claims
  public let digests: [SdJwtDigest]

  /// The decoded claims of the disclosures of the SD-JWT
  public let disclosableClaims: [SdJWTClaim]

  // MARK: Equatable

  public static func == (lhs: SdJWT, rhs: SdJWT) -> Bool {
    lhs as JWT == rhs as JWT && // Compare inherited properties
      lhs.disclosableClaims == rhs.disclosableClaims &&
      lhs.digests == rhs.digests
  }

}

extension SdJWT {
  /// Add the disclosed claims on the root of the VC.
  /// Useful for operations such as presentation.
  /// Returns raw credential with disclosed claims without `_sd` key
  public func replaceDigestsWithDisclosedClaims() throws -> String {
    let sdKey = "_sd"
    guard let jwtPayload = JWTDecoder().decodePayload(from: raw) else {
      throw SdJWTError.invalidJWTPayload
    }
    guard
      var payloadDictionary = try JSONSerialization.jsonObject(with: jwtPayload) as? [String: Any],
      payloadDictionary[sdKey] as? [String] != nil
    else {
      throw SdJWTError.invalidJWTPayload
    }

    for claim in disclosableClaims {
      do {
        guard payloadDictionary[claim.key] == nil else {
          throw SdJWTError.invalidClaimKey // ignore claims with duplicated key in the VC (including disclosed array elements)
        }
        payloadDictionary[claim.key] = try claim.anyValue()
      }
      catch { /* ignore this claim */ }
    }
    payloadDictionary.removeValue(forKey: sdKey)

    let jsonData = try JSONSerialization.data(withJSONObject: payloadDictionary)
    guard let jsonString = String(data: jsonData, encoding: .utf8) else {
      throw SdJWTError.encodingDisclosureError
    }
    return jsonString
  }

  public func applySelectiveDisclosure(for keys: [String]) throws -> SdJWT {
    guard let rawJWT = raw.separatedByDisclosures.first else { throw SdJWTError.invalidJWTPayload }
    let disclosures = disclosableClaims.filter { keys.contains($0.key) }.map(\.disclosure)
    let rawDisclosures = disclosures.isEmpty ? "" : disclosures.joined(separator: Self.disclosuresSeparator) + Self.disclosuresSeparator
    return try SdJWT(from: rawJWT + Self.disclosuresSeparator + rawDisclosures)
  }
}
